package com.example.wiprotest.service;import com.example.wiprotest.exceptions.DaoException;import com.example.wiprotest.model.CalculatedPrice;import com.example.wiprotest.model.InstrumentPriceHistory;import com.example.wiprotest.model.InstrumentPriceModifier;import com.example.wiprotest.utils.InstrumentPriceHistoryReader;import org.junit.jupiter.api.Test;import org.mockito.Mockito;import java.io.IOException;import java.io.InputStream;import java.text.ParseException;import java.util.List;import java.util.stream.Collectors;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.atLeast;import static org.mockito.Mockito.verify;class CalculatorImplTest {	@Test	void calculatePrices() throws IOException, ParseException, DaoException {		// GIVEN		InstrumentPriceModifierDao instrumentPriceModifierDao = Mockito.mock(InstrumentPriceModifierDao.class);		Mockito.when(instrumentPriceModifierDao.getByName(eq("INSTRUMENT1"))).thenReturn(			new InstrumentPriceModifier(1, "INSTRUMENT1", 1000d)		);		Mockito.when(instrumentPriceModifierDao.getByName(eq("INSTRUMENT2"))).thenReturn(			// modifier set to 0 meaning this instrument is considered of no value			new InstrumentPriceModifier(2, "INSTRUMENT2", 0)		);		Mockito.when(instrumentPriceModifierDao.getByName(eq("INSTRUMENT3"))).thenReturn(			new InstrumentPriceModifier(3, "INSTRUMENT3", 1)		);		List<InstrumentPriceHistory> history = loadHistory();		// WHEN		List<CalculatedPrice> calculatedPrices = new CalculatorImpl(instrumentPriceModifierDao).calculatePrices(history);		// THEN		assertEquals(3, calculatedPrices.size()); // the 3 different instruments in the sample list		assertTrue(calculatedPrices.stream().anyMatch(item -> "INSTRUMENT1".equals(item.name())));		assertTrue(calculatedPrices.stream().anyMatch(item -> "INSTRUMENT2".equals(item.name())));		assertTrue(calculatedPrices.stream().anyMatch(item -> "INSTRUMENT3".equals(item.name())));		assertEquals(0,			calculatedPrices.stream().filter(item -> "INSTRUMENT2".equals(item.name())).toList().get(0).calculatedPrice()		);		verify(instrumentPriceModifierDao, atLeast(1)).getByName(eq("INSTRUMENT1"));		verify(instrumentPriceModifierDao, atLeast(1)).getByName(eq("INSTRUMENT2"));		verify(instrumentPriceModifierDao, atLeast(1)).getByName(eq("INSTRUMENT3"));	}	private static List<InstrumentPriceHistory> loadHistory() throws IOException, ParseException {		try(InputStream samples =				Thread.currentThread().getContextClassLoader().getResourceAsStream("example_input.txt")) {			return InstrumentPriceHistoryReader.readHistoryLog(samples);		}	}}